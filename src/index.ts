import * as core from '@actions/core'
import * as github from '@actions/github'
import { Octokit } from '@octokit/rest'
import type { Context } from '@actions/github/lib/context.js'
import { runPipeline } from './pipeline.js'
import { postReactionOnTriggerComment } from './github/comments.js'

// GitHub's permission levels in ascending order.
const PERMISSION_RANK: Record<string, number> = {
  none: 0,
  read: 1,
  triage: 2,
  write: 3,
  admin: 4,
}

function shouldRun(trigger: string, triggerPhrase: string, ctx: Context): boolean {
  if (trigger === 'comment') {
    // Must be an issue_comment event on a PR
    if (ctx.eventName !== 'issue_comment') return false

    const issue = ctx.payload.issue as { pull_request?: unknown } | undefined
    if (!issue?.pull_request) return false

    const comment = ctx.payload.comment as { body?: string } | undefined
    if (!comment?.body?.includes(triggerPhrase)) return false

    return true
  }

  if (trigger === 'auto') {
    // Must be a pull_request event (opened or synchronize)
    if (ctx.eventName !== 'pull_request') return false
    const action = ctx.payload.action as string | undefined
    return action === 'opened' || action === 'synchronize'
  }

  core.warning(`Unknown trigger mode: ${trigger}. Supported: 'comment', 'auto'`)
  return false
}

/**
 * Returns true if the commenter is allowed to trigger a review.
 *
 * Blocks bot accounts unconditionally (logins ending in [bot]).
 * For humans, checks that their repository permission is >= minimumRole.
 * This prevents anyone who can merely read or comment on a public repo
 * from burning API credits.
 */
async function isActorAuthorized(
  octokit: Octokit,
  ctx: Context,
  minimumRole: string,
): Promise<boolean> {
  const actor = (ctx.payload.comment as { user?: { login?: string; type?: string } } | undefined)
    ?.user

  if (!actor?.login) {
    core.warning('Could not determine commenter identity; skipping review.')
    return false
  }

  // Block bots â€” includes github-actions[bot], dependabot[bot], etc.
  if (actor.type === 'Bot' || actor.login.endsWith('[bot]')) {
    core.info(`Skipping review: commenter ${actor.login} is a bot.`)
    return false
  }

  const { owner, repo } = ctx.repo

  let permission: string
  try {
    const { data } = await octokit.rest.repos.getCollaboratorPermissionLevel({
      owner,
      repo,
      username: actor.login,
    })
    permission = data.permission
  } catch {
    // 404 means not a collaborator at all â€” treat as 'none'
    permission = 'none'
  }

  const actorRank = PERMISSION_RANK[permission] ?? 0
  const requiredRank = PERMISSION_RANK[minimumRole] ?? PERMISSION_RANK['write']!

  if (actorRank < requiredRank) {
    core.info(
      `Skipping review: ${actor.login} has '${permission}' on this repo (need '${minimumRole}').`,
    )
    return false
  }

  return true
}

async function run() {
  try {
    const trigger = core.getInput('trigger')
    const triggerPhrase = core.getInput('trigger-phrase')
    const ctx = github.context

    if (!shouldRun(trigger, triggerPhrase, ctx)) {
      core.info('Skipping review: trigger conditions not met.')
      return
    }

    // Token is always pre-generated by the workflow (e.g. via
    // actions/create-github-app-token) and passed in as github-token.
    const githubToken = core.getInput('github-token', { required: true })
    const octokit = new Octokit({ auth: githubToken })

    // For comment-based triggers, verify the commenter has sufficient repo access.
    // Auto-trigger is gated on push access by GitHub itself, so no extra check needed.
    if (trigger === 'comment') {
      const minimumRole = core.getInput('minimum-role') || 'write'
      const authorized = await isActorAuthorized(octokit, ctx, minimumRole)
      if (!authorized) return
    }

    // Add ðŸ‘€ reaction to trigger comment
    if (trigger === 'comment') {
      const commentId = (ctx.payload.comment as { id?: number } | undefined)?.id
      if (commentId) {
        await postReactionOnTriggerComment(octokit, ctx, commentId, 'eyes').catch(() => {
          // Non-fatal: reactions are best-effort
        })
      }
    }

    await runPipeline({
      apiKey: core.getInput('api-key', { required: true }),
      gateway: core.getInput('gateway'),
      model: core.getInput('model'),
      fastModel: core.getInput('fast-model') || undefined,
      skillsPath: core.getInput('skills-path'),
      failOnCritical: core.getInput('fail-on-critical') === 'true',
      octokit,
      context: ctx,
    })

    // Add ðŸš€ reaction when done
    if (trigger === 'comment') {
      const commentId = (ctx.payload.comment as { id?: number } | undefined)?.id
      if (commentId) {
        await postReactionOnTriggerComment(octokit, ctx, commentId, 'rocket').catch(() => {
          // Non-fatal
        })
      }
    }
  } catch (error) {
    core.setFailed(error instanceof Error ? error.message : String(error))
  }
}

run()
